# Exploits

## Exploit Server
Exploits should be run on a separate server(s) from the instance of CTFd. This allows for accommodations to be made for certain exploitable challenges without jeopardizing the integrity of the competition. It has the added benefit of spreading out traffic as well, as many contestants like nmap and similar network scanning tools, and this added traffic can cause the CTF server to have a loss in performance.

## Process Management
Challenge up time is an important metric for a successful CTF. Challenges with spotty up time are bad challenges immediately, regardless of the quality of their contents. As such, process management is important to a successful CTF. Void Linux (our operating system of choice) manages processes with Runit, however, many other operating systems utilizes systemd. Either way, challenges should likely be started on boot, and certainly attempt to bring themselves back up when they crash. This, accompanied with proper monitoring, will ensure problems are up as much as possible with as little work from the administrator as possible.

## Challenge Separation
It is important to consider the privileges of each challenge as you deploy them. It would not be prudent, for example, to allow the challenge with unrestricted local file includes to access the flags of other challenges. At the bare minimum, each challenge should likely be run as a separate user, without read access to other challenge files. In some instances, further measures might need to be taken, like containerization or running inside a VM, but these measures are more on a case by case basis.

## Challenge Management
It should be your goal to at the very least be able to manually duplicate the challenges without any resource currently on the exploits box, but it would be incredibly beneficial to be able to automate problem deployment with Ansible. The exploit box itself should not be trusted. As you are inviting people to come in and attack services on the box, losing challenge components should be planned for. Having the ability to rebuild exploits with Ansible not only allows for the exploit box to be rebuilt as necessary, but also allows challenges to be easily spun up in other contexts, saving yourself time in the instance you wish to reuse a problem. Planning for a challenge to be broken on the box minimizes possible outages by giving you the ability to easily get the challenge back to a known good state.

## Why Runit?
Runit is the default init for Void Linux, but is not tied to it. Runit can be run independently of Void, and we highly recommend it. Runit is lightweight and easy to configure, managing processes without too many bells and whistles. Runit configuration is a simple shell script. Below is an example Runit configuration, good for general exploitable challenges.

	#!/bin/sh
	exec chpst -u {{ challenge_user }}:{{ challenge_user }} {{ challenge_run_command }}

For Void Linux, these configuration scripts are stored in `/etc/sv/{{ folder_name }}` and to enable to process on start up, link them in the `/var/service` directory.

	ln -s /etc/sv/{{ foldername }} /var/service

Runit will then be able to check to process state, start and stop the process, and will expose the process id for consumption by other programs. The small amount of effort to have Runit manage the exploitable challenges will have a large payoff. When done correctly, any exploitable box can be rebooted and have all of the challenges functional after boot with no interaction from the administrator.
