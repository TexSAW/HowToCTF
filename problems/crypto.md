# Cryptography

Cryptography tends to be a difficult subject for the average contestant to approach. Real cryptography is backed by tons of math and work to make sure it can't be broken. As such, most cryptography challenges rely on breaking the implementation, not the underlying theory. Even this can trend towards convoluted and I highly recommend providing contestants with plenty of breadcrumbs to follow to the solution.

## Classical Ciphers
Classical ciphers make prime candidates for low level problems. The Caesar cipher is a trademark of many CTFs as Crypto 100, but can easily be substituted for something more "exotic" like a rail fence cipher or a key word cipher. For upper level classical ciphers, a mono-alphabetic substitution cipher can be solve easily enough with frequency analysis, but I would consider this the top end of classical cipher's difficulty.

## Cryptographic Primitives
Exploiting poorly implemented cryptographic primitives is what I would consider first challenging level of cryptography challenges. This tends to be something like breaking an md5 hash, factoring a small RSA modulus, or breaking the discrete logarithm problem. In each instance, a basic understanding of how these cryptographic building blocks must be utilized to break them, but these generally don't lead to practical attacks. As a general statement, the average contestant can solve these by reading the Wikipedia article and looking around for the appropriate library. In instances where this might be considered too difficult, other cryptography-like problems can be implemented, like figuring out something is EBCDIC encoded or working with base64 data. Overall, for most competitions, these types of problems should be the bulk of your cryptography section.

## Real world attacks
The highest level challenges should be based on attacks that can be found in the real world. One (perhaps overused) is a padding oracle attack on AES-CBC, that was shown in the POODLE OpenSSL vulnerability. Similarly, there was an [attack on RSA and DSA](https://factorable.net/weakkeys12.extended.pdf) where moduli generated with shared factors could easily be broken with the Euclidean Algorithm for GCD. These kinds of attacks require knowledge past just how the system work, but up to a firm grasp of where they get their security and exactly where input or leaked information can be used to break it. With proper "bread crumbs", setting these types of attacks not only educates about real world examples of vulnerabilities, but offers a real challenge to even the most advanced contestants. 
